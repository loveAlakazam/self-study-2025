# [[코드팩토리] Nestjs REST API 백엔드 완전정복 마스터 클래스](https://www.inflearn.com/course/nestjs-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5-%EB%A7%88%EC%8A%A4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-1/dashboard)

## nodejs

- 오픈소스 / 크로스 플랫폼 / 자바스크립트 런타임

- 오픈소스: 누구나 볼 수 있는 오픈소스코드 이다.
- 크로스 플랫폼: 여러 OS에서 사용됨
- 자바스크립트 런타임: 자바스크립트(TS도 포함) 를 실행시킬 수 있다.

## nodejs 기술적인 소개

- 다양한 자바스크립트엔진
  - v8: 속도가 빠르다
  - spiderMonkey: firefox에서 사용되는 엔진
  - safari: macOS에서 사용되는 엔진
- 컴파일언어(compiled)와 인터프리터(interpreted) 언어
  - 컴파일언어: 프로그램을 실행하기전에 작성된 코들르 기계어로 한번에 모두 변환후에 실행
    - ex) 한번에 영어-> 한국어로 변환
    - 실행속도가 빠르다.
    - 일부수정하면 수정한걸 다시 변환시켜야된다. - 변경할때마다 전체를 다 컴파일해야된다.
  - 인터프리터언어: 코드를 한줄씩 실행하면서 동시에 변환됨
    - ex) 한줄씩 통역사가 영어->한국으로 변환
    - 실행속도가 비교적 느리다. - 통역사가 해석할 시간이 필요함.
    - 코드 변경이 있을때마다 바로 변환시킨다.
  - JIT(Just In Time Compilation)
    - 인터프리터방식과 컴파일방식의 장점을 모아둔다.
    - v8엔진도 JIT 컴파일방식을 사용한다.
    - Ignition
    - Turbofan: 자주사용하는 코드는 머신코드를 최적화
- 소스코드 와 바이트코드와 머신코드

  - 소스코드: 사람이 이해할 수 있는 코드
    - 고수준언어
    - 1만줄
  - 바이트코드: 가상환경과 기계가 읽을 수 있는 코드로 변환시켜준다.
    - CPU가 읽을 수 있는 머신코드로 변환시켜준다.
    - 플랫폼에 종속성이 없고 인터프리터가 있으면 실행이 가능하다.
    - 컴파일속도는 빠른데, 실행속도는 느리다.
    - 80만줄
  - 머신코드: CPU가 이해하여 바로 읽을 수 있는 코드
    - 저수준언어
    - 컴파일속도는 느린데, 실행속도는 빠르다.
    - 8000만줄

- nodejs 싱글스레드 모델이다.
  - 스레드
  - 이벤트루프
  - 이벤트큐
  - 워커스레드
  - 이벤트루프가 막혀있지 않도록 수행.
  - non-blocking 요청
  - blocking 요청
    - 오래걸리는 작업을 요청할 때
    - 이벤트큐 -> 이벤트룹 -> 워커스레드

## HTTP

- 클라이언트와 서버가 통신하는 방법중 하나
- 클라이언트가 요청을 보내면 서버가 응답을 반환한다.
- 요청과 응답의 구조화된 데이터를 보낼때 일반적으로 json 구조를 사용한다.

클라이언트가 서버에게 요청을 보내는 프로토콜은 http이다.

### json

- js 객체 또는 여타언어의 map과 구조가 매우 비슷하다.
- 요청과 응답의 body에 사용되는 구조
- 보낼때 string으로 변환하고 받으면 다시 json으로 변환한다.
- key, value쌍으로 이뤄져있고 콜론을 기준으로 왼쪽이 key, 오른쪽이 value가 된다.
- key값은 string만 허용된다.
- value값은 자유로운 타입을 허용한다. 숫자, string, 중첩된 json, list등이 허용.

### http 요청데이터 구성요소

- url: 요청을 보내는 주소
  - url예: `https://inflearn.com/courses/lecture?courseId=331985&unitId=184028&tab=curriculum&subtitleLanguage=ko`
  - `scheme`:`host`/`path`?`query-parameter`
    - scheme: 프로토콜(http, https)
    - host: 도메인
    - path: 요청한 리소스
    - query-parameter: 요청하는 리소스에 대한 추가정보(필터링에 많이 사용됨)
      - `?` 이후에 `key=검색값`으로 질의한다.
      - 2개이상이면 &를 붙여서 질의한다.
- method: 요청의 종류/타입 (get/post/put/patch/delete)
  - 같은 url에 여러개의 method로 정의할 수 있다. 하지만 url이 동일해도, method가 다르면 아예다른 요청이다.
  - put: 데이터가 존재하면 update, 데이터가 존재하지 않으면 생성.
  - patch: 데이터를 update하는데만 부분/전체 수정에 사용. 데이터가 없으면 에러를 던진다.
  - method는 정해진 목적대로 사용해야하지만 개발자가 마음대로 기능을 정의할 수 있기때문에 강제되는 부분은 아니다.
    - => 목적에 맞게 method 방식대로 기능을 구현하자. 이건 개발자간의 약속이다.
- header: 요청의 메타데이터
  - 메타데이터: 데이터에 관련된 데이터
    - 요청 데이터에 대한 정보들을 나타낸다.
    - host, cookie, user-agent, accept 등 key-value 쌍으로 들어감.
      - 쿠키, 인증토큰, 요청바이트길이, 요청/응답을 보낸 호스트요청할 때 사용된 클라이언트 타입과 버젼등을 정의
  - key/value 형태로 정의되어있고 key, value모두 string이다.
  - 라이브러리/ 프레임워크 환경에 의해 자동생성되는 값들이 많고, 직접 값을 변경하는 경우는 body보다 상대적으로 적다.
- body: 요청에 관련된 데이터이며 json구조로 나타내어있다.
  - 요청에대한 로직수행에 직접적으로 필요한 정보를 정의한다.
  - 일반적으로 json구조를 사용한다
  - 헤더는 요청자체에 대한 정보를 담고있지만, 바디는 요청을 수행하는 로직에대한 필요한 데이터를 담고 있다.

### http 응답데이터 구성요소

- status code: 응답코드
  - 응답의 상태에따라 코드값이 다르다.
  - 100-199: 정보응답
  - 200-299: 성공응답
    - 요청에대한 응답이 성공으로 돌아왔을 때
    - 200(OK), 201(Created, Post메소드에서 사용)
  - 300-399: 리다이렉션 메시지
    - 요청을 했는데 해당요청이 다른주소로 변경됐을 때
    - 301(Moved Permanently): 리소스가 영구적으로 이동됨. - 요청url이 다른곳으로 옮겼을때
  - 400-499: 클라이언트 에러 응답
    - 클라이언트(프론트엔드)에서 잘못됐을 때 나오는 에러
      - 400: 요청이 잘못됨(필수값 부족)
      - 401: 인증토큰/키가 잘못됨
      - 403: 접근이 불가능한 리소스 (인증된 사용자가 접근을 할 수 없음)
      - 404: 존재하지 않은 리소스
      - 405: Method not allowed: 허가되지 않은 요청. 정의되지 않은 메소드를 요청할때 사용.
  - 500-599: 서버 에러 응답
    - 서버에서 잘못됐을 때 나오는 에러
      - 500: 알수 없는 서버에러 서버에서는 크리티컬한 에러.
- header
- body
